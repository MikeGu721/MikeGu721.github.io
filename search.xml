<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>安卓开发学习笔记--文本控件</title>
      <link href="/2020/02/14/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6/"/>
      <url>/2020/02/14/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>​    笔者马上就要毕业了，虽然是船舶与海洋工程专业，但是毕业设计选了个安卓app开发相关的，之前老师让我去学学C#，学完之后发现，Android Studio里面主要是用Java作为脚本语言进行开发的，所以恶补一通Java知识后，勉勉强强开始了我的安卓开发之旅，打算整理一些笔记发到博客上来，希望能与大家一同分享</p><h1 id="安卓常用控件"><a href="#安卓常用控件" class="headerlink" title="安卓常用控件"></a>安卓常用控件</h1><ul><li>标签TextView</li></ul><p>​    在Android中，TextView为标签控件，标签用于显示信息，不能被用户手动修改，其固有属性一般都存放于activity_main.xml中，必须要有的两个是android:layout_width和android:layout_height，前者表示宽，后者表示高，对应的值可以是固定数字，也可以是wrap_content和match_parent，第一个表示占满，第二个表示根据内容自动变更大小。格式如下：</p><p>​    <code>android:layout_width=&quot;match_parent&quot;</code></p><p>​    <code>android:layout_height=&quot;wrap_content&quot;</code></p><p>除此之外还能加上id以及文本内容——这些并不是一定要有的，代码如下：</p><p>​    <code>android:id=&quot;@+id/tvThisIsATest&quot;</code></p><p>​    <code>android:text=&quot;文本内容&quot;</code></p><p>然后可以设置字体，大致有三种，粗体(bold)，斜体(italic)，粗斜体(bold_italic)，代码如下：</p><p>​    <code>android:textStyle=&quot;bold&quot;</code></p><p>其他控件大多都继承自TextView，所以上述属性其他控件也都拥有，之后不再赘述</p><ul><li>按钮Button</li></ul><p>​    Android中的按钮用于响应用户的点击操作，相应的点击事件需要在代码里注册View.OnClickListener监听器，具体代码我放在本文末尾</p><ul><li>文本框EditView</li></ul><p>​    Android中的文本框用于用户输</p><hr><p>下面通过设计一个用户登录界面，来体现控件的声明、关联、回调</p><h1 id="用户登录界面设计"><a href="#用户登录界面设计" class="headerlink" title="*用户登录界面设计"></a>*用户登录界面设计</h1><p>用户可以在用户名和密码中输入相应字符，按下确定后可以在下方的TextView中显示出来，按下取消后可以将输入的内容全部删除</p><p>先在activity_main.xml中设置控件属性，总共两个TextView，三个EditText，两个Button</p><p>其中三个EditText笔者这里起id为etUserName etPassword etResult</p><p>两个Button笔者这里起id为btnOk和btnCancel</p><p>来到MainActivity.java中</p><ul><li>1.关联代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btnOk;</span><br><span class="line"><span class="keyword">private</span> Button btnCancel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EditText etUserName;</span><br><span class="line"><span class="keyword">private</span> EditText etPassWord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TextView tvResult;</span><br></pre></td></tr></table></figure><ul><li>2.关联控件：</li></ul><p><em>注：这步要写在@Override onCreate的下面</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btnOk = (Button)findViewById(R.id.btnOk);</span><br><span class="line">btnCancel = (Button)findViewById(R.id.btnCancel);</span><br><span class="line"></span><br><span class="line">etUserName = (EditText)findViewById(R.id.etUserName);</span><br><span class="line">etPassWord = (EditText)findViewById(R.id.etPassWords);</span><br><span class="line"></span><br><span class="line">tvResult = (TextView)findViewById(R.id.tvResult);</span><br></pre></td></tr></table></figure><ul><li>3.设置回调</li></ul><p><em>注：这步也要写在@Override onCreate的下面</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">btnOk.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        String username &#x3D; etUserName.getText().toString();</span><br><span class="line">        String password &#x3D; etPassWord.getText().toString();</span><br><span class="line">        tvResult.setText(&quot;用户名：&quot;+username+&quot;，密码：&quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">btnCancel.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v)&#123;</span><br><span class="line">        etUserName.setText(&quot;&quot;);</span><br><span class="line">        etPassWord.setText(&quot;&quot;);</span><br><span class="line">        tvResult.setText(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是一个非常简单的安卓应用，主要是熟悉一下安卓控件的使用方法，如何声明、关联、设置回调</p><p>最后，可以在actvity_main中设置密码输入方式：</p><p><code>android:inputType=&quot;textPassword&quot;</code></p><p>也可以设置提示信息：</p><p><code>android:ihint=&quot;请输入密码&quot;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈C++的整个标准库(STL)模板</title>
      <link href="/2020/01/20/%E8%B0%88%E8%B0%88C-%E7%9A%84%E6%95%B4%E4%B8%AA%E6%A0%87%E5%87%86%E5%BA%93-STL-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/01/20/%E8%B0%88%E8%B0%88C-%E7%9A%84%E6%95%B4%E4%B8%AA%E6%A0%87%E5%87%86%E5%BA%93-STL-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>继前一篇文章讨论了Vector库的用法，我觉得大多数STL库内的函数比较简单，所以想直接做一个合集，考虑到algorithm头文件包含的函数很多，而且较为复杂，所以打算下次专门写一篇：</p><a id="more"></a><p>注：本文章内的代码串只是把所有的命令、声明语句写了出了，重在单条语句内容那个，无逻辑性，照搬复制可能无法运行。</p><p>注：Vector、Set、String这三个是容器，为了方便理解我会在标号为1~8的内容中介绍其功能为数组，但说是数组只是帮助理解，实际上这三个是容器</p><h1 id="1、Vector"><a href="#1、Vector" class="headerlink" title="1、Vector"></a>1、Vector</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Vector_Test() &#123;</span><br><span class="line">vector&lt;int&gt; name1;&#x2F;&#x2F;创建一维长度可变数组</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; name2;&#x2F;&#x2F;创建二位长度可变数组</span><br><span class="line">vector&lt;int&gt; name3[30];&#x2F;&#x2F;创建一位定长数组</span><br><span class="line">vector&lt;int&gt;::iterator it;&#x2F;&#x2F;创建it指针</span><br><span class="line">name1.push_back(1);&#x2F;&#x2F;name1末尾加上元素1</span><br><span class="line">name1.pop_back();&#x2F;&#x2F;name1末尾减去一个元素</span><br><span class="line">name1.size();&#x2F;&#x2F;求name1数组长度</span><br><span class="line">name1.clear();&#x2F;&#x2F;清空name1数组</span><br><span class="line">name1.insert(name1.begin() + 0, 6);&#x2F;&#x2F;等价于name1[0]&#x3D;6</span><br><span class="line">name1.erase(name1.begin() + 0);&#x2F;&#x2F;擦除name1[0]的元素</span><br><span class="line">name1.erase(name1.begin(), name1.end());&#x2F;&#x2F;擦除[beging,end)的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector的用途：</p><p>​    a、 储存数据</p><p>​    b、 用邻接表存储图</p><h1 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Set_Test() &#123;</span><br><span class="line">set&lt;int&gt; name1;&#x2F;&#x2F;建立可变长一维数组name1</span><br><span class="line">set&lt;set&lt;int&gt; &gt; name2;&#x2F;&#x2F;建立可变长二维数组name2</span><br><span class="line">set&lt;int&gt; name3[30];&#x2F;&#x2F;建立定长素组name3</span><br><span class="line">name1.insert(3);&#x2F;&#x2F;插入3</span><br><span class="line">name1.insert(4);&#x2F;&#x2F;插入4</span><br><span class="line">name1.insert(3);&#x2F;&#x2F;插入3</span><br><span class="line">name1.insert(2);&#x2F;&#x2F;插入2</span><br><span class="line">for (set&lt;int&gt;::iterator it &#x3D; name1.begin(); it !&#x3D; name1.end(); it++) &#123;</span><br><span class="line">printf(&quot;%d&quot;, *it);</span><br><span class="line">&#125;&#x2F;&#x2F;建立指针it，从头到尾遍历name1并打印</span><br><span class="line">set&lt;int&gt;::iterator it &#x3D; name1.find(3);&#x2F;&#x2F;返回元素值等于3的位置</span><br><span class="line">name1.erase(it);&#x2F;&#x2F;擦掉it指向的位置</span><br><span class="line">name1.erase(4);&#x2F;&#x2F;擦掉元素4</span><br><span class="line">name1.erase(name1.begin(), name1.end());&#x2F;&#x2F;擦掉[name1.begin(),name1.end())的元素</span><br><span class="line">name1.size();&#x2F;&#x2F;求name1的长度</span><br><span class="line">name1.clear();&#x2F;&#x2F;清空name1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set函数的用途</p><p>​    a、自动升序排列且自动去除重复元素</p><h1 id="3、String"><a href="#3、String" class="headerlink" title="3、String"></a>3、String</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void String_Test() &#123;</span><br><span class="line">string str &#x3D; &quot;abcdefg&quot;;&#x2F;&#x2F;string定义</span><br><span class="line">string name;&#x2F;&#x2F;string定义</span><br><span class="line">cin &gt;&gt; name;&#x2F;&#x2F;输入string</span><br><span class="line">cout &lt;&lt; name;&#x2F;&#x2F;输出string</span><br><span class="line">for (int i &#x3D; 0; i &lt; str.length; i++)&#x2F;&#x2F;正常的字符串输出</span><br><span class="line">printf(&quot;%c&quot;, str[i]);</span><br><span class="line">printf(&quot;%s\n&quot;, str.c_str);&#x2F;&#x2F;将string型str使用c_str()变为字符数组</span><br><span class="line">for (string::iterator it &#x3D; str.begin(); it !&#x3D; str.end(); it++) &#x2F;&#x2F;指针输出</span><br><span class="line">printf(&quot;%c&quot;, *it);</span><br><span class="line">name &#x3D; name + str;&#x2F;&#x2F;string下的字符串可以直接相加减</span><br><span class="line">cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">if (name &gt; str)cout &lt;&lt; name;&#x2F;&#x2F;string下的字符串可直接进行字典序比较</span><br><span class="line">else cout &lt;&lt; str;</span><br><span class="line">str.length() &#x3D;&#x3D; str.size();&#x2F;&#x2F;length()和size()函数在string函数里一样</span><br><span class="line">str.insert(3, name);&#x2F;&#x2F;在str第三个元素后插入name字符串</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">string::iterator it &#x3D; str.begin() + 4;&#x2F;&#x2F;指针it定义</span><br><span class="line">str.erase(it);&#x2F;&#x2F;擦除指针it指向的位置</span><br><span class="line">str.erase(0, 5);&#x2F;&#x2F;擦除0号元素以及往后的5-1个元素</span><br><span class="line">str.erase(str.begin(), str.end());&#x2F;&#x2F;擦除从[str.begin(),str.end())</span><br><span class="line">str.clear;&#x2F;&#x2F;清除str字符串的内容</span><br><span class="line">str.substr(pos, len);&#x2F;&#x2F;显示从pos号元素开始，以及往后的len-1个元素</span><br><span class="line">string::npos &#x3D;&#x3D; -1;&#x2F;&#x2F;string::npos的默认值是-1</span><br><span class="line">string::npos &#x3D;&#x3D; 4294967295;&#x2F;&#x2F;但因为string::npos是定义在unsigned情况下的，所以其的默认值也可以是4294967295——要讲清楚这个问题得学习计算机组成原理，笔者这边就提一句，-1和4294967295的差别仅在于规定格式不同，一个规定第一位为符号位，另一个规定第一位为数字，而&#x3D;&#x3D;判断语句不判断格式，仅判断前后两值在计算机中存储的二进制电平。</span><br><span class="line">str.find(&quot;abc&quot;);&#x2F;&#x2F;在str中找到字符串，返回第一个字符所在的位置</span><br><span class="line">string str1 &#x3D; &quot;Maybe you will turn around.&quot;;</span><br><span class="line">string str2 &#x3D; &quot;will you&quot;;</span><br><span class="line">cout&lt;&lt;str1.replace(10, 4, str2)&lt;&lt;endl;&#x2F;&#x2F;将10号元素开始，以及往后的4-1号元素替换成str2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String函数的用途：</p><p>​    a、提供一套更为简便的字符串处理函数，但注意其中的字符串查找函数的复杂度为O(mn)</p><h1 id="4、Map"><a href="#4、Map" class="headerlink" title="4、Map"></a>4、Map</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Map_Test() &#123;</span><br><span class="line">map&lt;char, int&gt; name1;</span><br><span class="line">map&lt;set&lt;int&gt;, string&gt; name2;&#x2F;&#x2F;将一个set容器映射到字符串</span><br><span class="line">name1[&#39;c&#39;] &#x3D; 20;&#x2F;&#x2F;键到值的映射</span><br><span class="line">printf(&quot;%d&quot;, name1[&#39;c&#39;]);&#x2F;通过下标访问</span><br><span class="line">map&lt;char, int&gt;::iterator it &#x3D; name1.find(&#39;c&#39;);&#x2F;&#x2F;通过迭代器访问</span><br><span class="line">printf(&quot;%c %d&quot;, it-&gt;first, it-&gt;second);&#x2F;&#x2F;first表示键，second表示值</span><br><span class="line">name1.erase(it);&#x2F;&#x2F;擦除it指向的地方</span><br><span class="line">name1.erase(&#39;c&#39;);&#x2F;&#x2F;擦除键为c的地方</span><br><span class="line">name1.erase(name1.begin(), name1.end());&#x2F;&#x2F;擦除[name1.begin(),name1.end())的内容</span><br><span class="line">name1.size();&#x2F;&#x2F;求name1的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map函数的功能：</p><p>​    a、map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）</p><p>​    b、map需要确定映射前类型（键key）和映射后类型（值value），如果是字符串到整型的映射，必须使用string而不能使用char数组</p><p>​    c、map会以键从小到大自动排序</p><h1 id="5、Queue"><a href="#5、Queue" class="headerlink" title="5、Queue"></a>5、Queue</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Queue_Test() &#123;</span><br><span class="line">queue&lt;int&gt; name;&#x2F;&#x2F;初始化queue</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">name.push(i);&#x2F;&#x2F;入队</span><br><span class="line">&#125;</span><br><span class="line">name.pop();&#x2F;&#x2F;出队队首元素</span><br><span class="line">if (empty(name) &#x3D;&#x3D; false)&#x2F;&#x2F;判断是否队空</span><br><span class="line">name.push(10);</span><br><span class="line">printf(&quot;%d  %d&quot;, name.front, name.back());&#x2F;&#x2F;输出队头和队尾元素</span><br><span class="line">name.size();&#x2F;&#x2F;求队长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue函数的功能：</p><p>​    a、广度优先搜素时不必自己实现队列</p><p>​    b、要有在用front()和back()前判断empty()的习惯</p><h1 id="6、Priority-queue"><a href="#6、Priority-queue" class="headerlink" title="6、Priority_queue"></a>6、Priority_queue</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Priority_Queue_Test() &#123;</span><br><span class="line">priority_queue&lt;int&gt; name;&#x2F;&#x2F;数字大的放队首</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q1;&#x2F;&#x2F;与上面的声明完全一样，数字大的放队首</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2;&#x2F;&#x2F;数字小的放在队首</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">name.push(i);&#x2F;&#x2F;入队</span><br><span class="line">&#125;</span><br><span class="line">name.empty();&#x2F;&#x2F;判断队空</span><br><span class="line">int i &#x3D; name.top();&#x2F;&#x2F;提取队首元素</span><br><span class="line">name.pop();&#x2F;&#x2F;出队</span><br><span class="line">name.size();&#x2F;&#x2F;判断队的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是最基本的优先级队列命令，下面讲一下优先级队列的结构体重载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct fruit &#123;&#x2F;&#x2F;解释写在下面</span><br><span class="line">string name;</span><br><span class="line">int price;</span><br><span class="line">friend bool operator&lt;(fruit f1, fruit f2)&#123;</span><br><span class="line">return f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里强调在fruit结构体中，首先关注price，friend为友元，在此不解释；bool operator&lt;(fruir f1, fruit f2)是对fruit类型的操作符”&lt;”进行了重载（重载&gt;或=会编译出错，只能重载&lt;）将其定义为小于号的作用，则做到了price越高优先级越高——这里的排序和sort以及cmp有点类似，但读者应该能发现，其作用是相反的。</p><h1 id="7、Stack"><a href="#7、Stack" class="headerlink" title="7、Stack"></a>7、Stack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Stack_Test() &#123;</span><br><span class="line">stack&lt;int&gt; name;&#x2F;&#x2F;初始化栈</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">name.push(i);&#x2F;&#x2F;入栈</span><br><span class="line">&#125;</span><br><span class="line">name.pop();&#x2F;&#x2F;出栈</span><br><span class="line">if (name.empty() !&#x3D; true)&#x2F;&#x2F;判断栈空</span><br><span class="line">int i &#x3D; name.top();&#x2F;&#x2F;取栈顶元素</span><br><span class="line">printf(&quot;%d&quot;, name.size());&#x2F;&#x2F;判断栈的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack函数的功能</p><p>​    a、模拟一些递归，防止程序对栈内存的限制而导致程序运行出错</p><h1 id="8、Pair"><a href="#8、Pair" class="headerlink" title="8、Pair"></a>8、Pair</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void Pair_Test() &#123;</span><br><span class="line">pair&lt;string, int&gt;p1;&#x2F;&#x2F;初始化pair</span><br><span class="line">pair&lt;string, int&gt;p2(&quot;first_p2&quot;, 1);&#x2F;&#x2F;初始化pair并赋值</span><br><span class="line">p1&#x3D;pair&lt;string, int&gt;(&quot;first_p1&quot;, 2);&#x2F;&#x2F;快速赋值方法1</span><br><span class="line">p2&#x3D;make_pair(&quot;second_p2&quot;, 3);·&#x2F;&#x2F;快速赋值方法2</span><br><span class="line">p1.first &#x3D; &quot;second_p1&quot;;&#x2F;&#x2F;输入p1前部</span><br><span class="line">p1.second &#x3D; 4;&#x2F;&#x2F;输入p1后部</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; &quot; &quot; &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line">if (p1 &#x3D;&#x3D; p2)printf(&quot;p1&#x3D;p2&quot;);&#x2F;&#x2F;先判断first，在first相等的情况下判断second</span><br><span class="line">else if (p1 &gt; p2) printf(&quot;p1&gt;p2&quot;);&#x2F;&#x2F;同上</span><br><span class="line">else if (p1 &lt; p2) printf(&quot;p1&lt;p2&quot;);&#x2F;&#x2F;同上上</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair函数的功能：</p><p>​    a、同时保存两种数据类型的数据，可以代替二元体结构，省去编写结构体的代码</p><p>​    b、作为map的键来进行插入，如下代码</p><pre><code>map&lt;string, int&gt;mp;//初始化mapmp.insert(make_pair(&quot;Use make_pair to input&quot;, 10));//用make_pair进行输入mp.insert(pair&lt;string, int&gt;(&quot;Use pair to input&quot;, 20));//用pair进行输入for (map&lt;string, int&gt;::iterator it = mp.begin(); it != mp.end(); it++)//遍历输出map    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</code></pre><h1 id="9、Algorithm"><a href="#9、Algorithm" class="headerlink" title="9、Algorithm"></a>9、Algorithm</h1><p>Algorithm头文件里包含的函数比较多，我先来列举一下</p><p>1、max()；min()；abs()；swap()；next_permutation()；fill()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void Algorithm_Test_1() &#123;</span><br><span class="line">int a &#x3D; 2, b &#x3D;- 6, c &#x3D; 9;</span><br><span class="line">printf(&quot;%d %d %d&quot;, max(a, b), min(b, c),abs(b));&#x2F;&#x2F;max()求最大值，min()求最小值，abs()求绝对值</span><br><span class="line">swap(a, b);&#x2F;&#x2F;swap()交换a，b的值</span><br><span class="line">printf(&quot;a &#x3D; %d; b &#x3D; %d&quot;, a, b);</span><br><span class="line">int d[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;</span><br><span class="line">reverse(d, d + 4);&#x2F;&#x2F;在区间[0,4)内的数组下标翻转</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)&#x2F;&#x2F;输出4 3 2 1 5 6 7 8 9 10</span><br><span class="line">printf(&quot;%d &quot;,d[i]);</span><br><span class="line">do &#123;</span><br><span class="line">printf(&quot;%d%d%d\n&quot;, d[0], d[1], d[2]);</span><br><span class="line">&#125; while (next_permutation(d, d + 3));</span><br><span class="line">&#x2F;&#x2F;next_permutation()的作用是将下标范围内的数组变换成下一种排列组合方式，如将123变成132，将321变成NULL</span><br><span class="line">fill(d, d + 9, 666);&#x2F;&#x2F;将666填在数组下标为[0,9)的范围内</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">printf(&quot;%d &quot;,d[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、sort()</p><p>sort的格式是：sort(首元素地址，尾元素地址的后一个地址，比较函数(可以不填));</p><pre><code>void Algorithm_Test_2_1() {    int a[10] = { 1,4,3,2,5,3,6,3,4,7 };    sort(a, a + 4);//将下标为0~3的数组内的元素按从小到大的顺序排列}</code></pre><p>这是最标准的sort了，作用也写在注释里了，那如果我们要sort完成不同情况的排序，必须人为的告诉sort函数该如何比较函数下面有三种比较函数的定义方法</p><pre><code>bool cmp_1(int a, int b) {//标准比较return a &gt; b;//a&gt;b时，a放在b的前面}void Algorithm_Test_2_2() {    int a[10] = { 1,4,3,2,5,3,6,3,4,7 };    sort(a, a + 4, cmp_1);//将下标为0~3的数组内的元素按从大到小的顺序排列}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;&#x2F;&#x2F;数组比较</span><br><span class="line">int x, y;</span><br><span class="line">&#125;ssd[10];</span><br><span class="line">bool cmp_2(node a, node b) &#123;</span><br><span class="line">return a.x &gt; b.x;&#x2F;&#x2F;a的x大于b的x时，a放在b的前面</span><br><span class="line">&#125;</span><br><span class="line">void Algorithm_Test_2_3() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">ssd[i].x &#x3D; i * i - 8i;</span><br><span class="line">ssd[i].y &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">sort(ssd, ssd + 8, cmp_2);&#x2F;&#x2F;将下标为0~3的数组内的元素按从小到大的顺序排列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool cmp_3(string a, string b) &#123;</span><br><span class="line">return a.length() &lt; b.length();&#x2F;&#x2F;长度小的字符串放在前面</span><br><span class="line">&#125;</span><br><span class="line">void Algorithm_Test_2_4() &#123;</span><br><span class="line">string str[3] &#x3D; &#123; &quot;aaa&quot;,&quot;bbbbbb&quot;,&quot;cc&quot; &#125;;</span><br><span class="line">sort(str, str + 3, cmp_3);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i++)&#x2F;&#x2F;输出：cc aaa bbbbbb</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、lower_bound()；upper_bound()</p><p>​    lower_bound()、upper_bound()返回的是指针或者迭代器，具体看括号内的是数组还是容器，数组和容器的问题我在本文章最开头的注中写过了，可以再回去看一眼。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Algorithm_Test_3() &#123;</span><br><span class="line">int a[10] &#x3D; &#123; 1,2,2,3,3,3,5,5,5,5 &#125;;</span><br><span class="line">int* lowerPos &#x3D; lower_bound(a, a + 10, 3);&#x2F;&#x2F;在[0,10)中，返回第一个大于等于6的数的指针或者迭代器</span><br><span class="line">int* upperPos &#x3D; upper_bound(a, a + 10, 3);&#x2F;&#x2F;在[0,10)中，返回第一个大于6的数的指针或者迭代器</span><br><span class="line">printf(&quot;%d, %d\n&quot;, lowerPos - a, upperPos - a);&#x2F;&#x2F;输出3, 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于C++标准库——vector函数</title>
      <link href="/2020/01/18/%E5%85%B3%E4%BA%8EC-%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2020/01/18/%E5%85%B3%E4%BA%8EC-%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>在写这篇文章时，笔者最近正在学习java，下了个editplus，用editplus编辑了内容，结果上传的时候布局特别不舒服，然后又花了好多时间在typora里重新排版，以后还是老老实实在typora里写博客吧。</p><a id="more"></a><p>1、vector函数<br>    a. 定义<br>        1). 首先，要加上<code>#include&lt;vector&gt;</code>引用头文件，还要加上<code>using namespace std;</code><br>        2). <code>vector&lt;typename&gt; name;</code> 相当于定义了一个可变长的数组<br>        3). <code>vector&lt;vector&lt;typrname&gt; &gt; name;</code> 相当于定义了一个二维数组<br>            ！ 注：上述定义二维数组中，&gt; &gt;之间要加空格，否则可能被视为移位操作<br>        4). <code>vector&lt;int&gt; vi[100];</code> 也是一种定义数组的方法，不过这种方法长度被定死了<br>    b. 元素访问<br>        1). 下标访问 vector[20];<br>        2). 通过迭代器访问：<br>            ！ 迭代器(iterator)可以视作指针，其定义如下<br>                <code>vector&lt;typename&gt;::iterator it;</code><br>            ！ 此时可以通过*it来访问vector里的元素<br>        3).代码举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">vi.push_back(i); &#x2F;&#x2F;在vi的末尾添加元素i</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt;::iterator it &#x3D; vi.begin(); &#x2F;&#x2F;vi.begin()为取vi的首元素地址，而it指向这个地址</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, *(it + i)); &#x2F;&#x2F;输出vi[i]</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            ！ 这里要提一嘴，既然有了begin()，那自然不能少了end()，end()是取数组最后的元素，并规定数组最后            的元素为空元素<br>​            ！ 又因为迭代器实现了两种自加操作，所以还有一种遍历vector的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for (vector&lt;int&gt;::iterator it &#x3D; vi.begin(); it !&#x3D; vi.end(); it++) &#123;</span><br><span class="line">printf(&quot;%d&quot;, *it);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c. vector常用函数实例解析<br>    1). push_back()<br>        ！ 我上面那串代码中也提到过，push_back(x)就是在vector后面添加一个元素x，时间复杂度为O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int exemple_push_back() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; vi.size(); i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, vi[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    2). pop_back()<br>​        ！ pop_back用来删除vector的尾元素，时间复杂度为O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int exempel_pop_back() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 1;</span><br><span class="line">i &lt;&#x3D; 3; i++)</span><br><span class="line">&#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vi.pop_back();</span><br><span class="line">for (int i &#x3D; 0; i &lt; vi.size(); i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, vi[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3). size()</p><p>​        ！ size用来获取vector中元素的个数，时间复杂度为O(1)，返回值为unsigned类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int exemple_size() &#123;</span><br><span class="line">    vector&lt;int&gt; vi; </span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, vi.size());</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    4). clear()<br>​        ！ 用来清空vector中所有元素，时间复杂度为O(vi.size())。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int exemple_pop_back() &#123; </span><br><span class="line">vector&lt;int&gt; vi; </span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vi.clear(); </span><br><span class="line">printf(&quot;%d &quot;, vi.size());</span><br><span class="line">return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    5). insert()<br>​        ！ insert(it,x)用来向vector任意迭代器it处插入元素x，时间复杂度O(vi.size())</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int exempel_pop_back() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) &#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vi.insert(vi.begin() + 2, -1);</span><br><span class="line">for (int i &#x3D; 0; i &lt; vi.size(); i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, vi[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    6). erase()<br>​        a. 删除单个元素：erase(it)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int exemple_erase_single() &#123;</span><br><span class="line">    vector&lt;int&gt; vi;</span><br><span class="line">    for (int i &#x3D; 5; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vi.erase(vi.begin() + 3);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; vi.size(); i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        b. 删除一个区域内的元素：erase(first,last)<br>​            注：删除的区间为左闭右开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">vector&lt;int&gt; vi;</span><br><span class="line">for (int i &#x3D; 5; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">vi.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">vi.erase(vi.begin() + 1, vi.begin() + 4);</span><br><span class="line">for (int i &#x3D; 0; i &lt; vi.size(); i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, vi[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d. vector常见用途<br>    1). 存储数据<br>        ！ vector本身可做数组<br>        ！ 可变长的特性很方便记录未知长度的数据个数<br>    2). 用邻接表存储图<br>        ！ 二维数组都有这个特性</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++的二分思想及其应用</title>
      <link href="/2020/01/13/%E5%9F%BA%E4%BA%8EC-%E7%9A%84%E4%BA%8C%E5%88%86%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2020/01/13/%E5%9F%BA%E4%BA%8EC-%E7%9A%84%E4%BA%8C%E5%88%86%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>昨天写了半天的简历，本以为写简历不要多少时间的，后来发现，好多公司都是让你提交一份简历附件，然后再让你填一堆东西，学习成绩、获奖情况什么的，基本上就是把简历里的东西再填到他们的选项里。一切弄好了后看了会儿日语，再把这个博客的搜索系统搞出来了，最后打打游戏一天就过去了。今天重整旗鼓，继续来搞算法</p><a id="more"></a><p>今天我先学到了一组比较简单的算法——二分查找</p><p>先是第一串代码，最标准的，用来实现二分查找x的代码</p><p>1.标准二分查找x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int A[], int left, int right, int x) &#123;</span><br><span class="line">int mid;</span><br><span class="line">while (left &lt;&#x3D; right) &#123;&#x2F;&#x2F;一定要判断等于0这一下</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid] &#x3D;&#x3D; x)return mid;</span><br><span class="line">else if (A[mid] &gt; x) &#123;</span><br><span class="line">right &#x3D; mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个算法非常简单，唯一需要注意的地方我已经标注出来了——while一定要判断left&lt;=right而不是left&lt;right，否则很有可能导致mid-&gt;right-1而left-&gt;right-&gt;x，下面再来看两个变种的二分查找</p><p>2.查找第一个大于等于x的数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int lower_bound(int A[], int left, int right, int x) &#123;</span><br><span class="line">int mid;</span><br><span class="line">while (left &lt; right) &#123;</span><br><span class="line">&#x2F;&#x2F;跳出循环时，若right&#x3D;mid+1 left&#x3D;mid+1</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid] &gt;&#x3D; x) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return left;&#x2F;&#x2F;此时mid小于等于x，输出left为大于等于x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有三个地方难以理解：</p><p>i.mid(right)指向x的场景：导致right指向mid，然后mid指向一个小于x的地方，left一直靠近，直到left=right-1时，mid=left+right/2=right-1，则left=right=mid+1=x的位置，跳出循环</p><p>ii.left指向x的场景：导致mid大于x，然后right慢慢逼近，直到right=left+1，下一步mid=(left+right)/2=left；A[mid]==x，right指向mid，跳出循环，返回left=right=mid=x的位置</p><p>iii.没有x的场景：right永远不会小于x，left在其最后一步之前不会大于x</p><p>3.查找第一个大于x的数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int upper_bound(int A[], int left, int right, int x) &#123;</span><br><span class="line">int mid;</span><br><span class="line">while (left &lt; right) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid] &gt; x) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过第二个算法的分析可以发现，返回等于x的情况只有mid指向x、left指向x、right指向x这三种情况</p><p>i.mid指向x时：left=mid+1跳过x</p><p>ii.left指向x时：right逼近到left+1位置时出现了mid指向x</p><p>iii.right指向x时：不可能出现，因为right指向x的前一步一定是mid指向x</p><p>上面两种变式理解了之后，接下来看看涉及开闭区间时的二分查找算法吧</p><p>4.左闭右闭区间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int solve1(int A[], int left, int right) &#123;</span><br><span class="line">int mid;</span><br><span class="line">while (left &lt; right) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid]&gt;&#x3D;x) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.左开右闭区间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int solve2(int left, int right) &#123;</span><br><span class="line">int mid;</span><br><span class="line">while (left + 1 &lt; right) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid]&gt;&#x3D;x) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.左闭右开区间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int solve2(int left, int right) &#123;&#x2F;&#x2F;左开右闭</span><br><span class="line">int mid;</span><br><span class="line">while (left &lt; right + 1) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (A[mid]&gt;&#x3D;x) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个算法的思路其实非常简单，拿第五个算法为例，退出循环时满足left+1=right，即在区间(left,right]中取得满足条件的值，又因为我们定义的时int型，所以就只能取到right了。</p><p>重点来了，int型，那我们如果不只是int型呢，这算法会有什么变化吗？</p><p>我们来看一些稍微高级一点但不难的应用：</p><p>7.二分法计算开根号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const double eps &#x3D; 1e-5;&#x2F;&#x2F;精度为10^-5</span><br><span class="line">double f(double x) &#123;</span><br><span class="line">return x*x;</span><br><span class="line">&#125;</span><br><span class="line">double solve(double L, double R) &#123;</span><br><span class="line">double left &#x3D; L, right &#x3D; R, mid;</span><br><span class="line">while (right - left &gt; eps) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (f(mid) &gt; 0) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断通过二分法来逼近x*x=0这个条件，那我们可以得出，任何一个方程，是否都可以通过这种二分法来求其特定区间内的零点呢？</p><p>8.计算f(x)=0在[L,R]上的解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const double eps &#x3D; 1e-5;</span><br><span class="line">double f(double x) &#123;</span><br><span class="line">return 在这里可以返回一个函数式;</span><br><span class="line">&#125;</span><br><span class="line">double solve(double L, double R) &#123;</span><br><span class="line">double left &#x3D; L, right &#x3D; R, mid;</span><br><span class="line">while (right - left &gt; eps) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;&#x2F;&#x2F;这步可根据开闭区间进行变化</span><br><span class="line">if (f(mid) &gt; 0) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.装水问题</p><p>有一半径为R的半圆形储水装置，长为l，请问在水的高度h为多少时，储水装置的体积与水的体积的比例为r？</p><p>之前两个算法弄懂了之后，这个算法的难点也就是写出大扇形和小扇形的面积比例公式了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">const double PI &#x3D; acos(-1.0);&#x2F;&#x2F;PI</span><br><span class="line">const double eps &#x3D; 1e-5;&#x2F;&#x2F;精度为10^-5</span><br><span class="line">double f(double R, double h) &#123;</span><br><span class="line">double alpha &#x3D; 2 * acos((R - h) &#x2F; R);</span><br><span class="line">double L &#x3D; 2 * sqrt(R * R - (R - h) * (R - h));</span><br><span class="line">double S1 &#x3D; alpha * R * R &#x2F; 2 - L * (R - h) &#x2F; 2;</span><br><span class="line">double S2 &#x3D; PI * R * R &#x2F; 2;</span><br><span class="line">return S1 &#x2F; S2;</span><br><span class="line">&#125;</span><br><span class="line">double solve(double R, double r) &#123;</span><br><span class="line">double left &#x3D; 0, right &#x3D; R, mid;</span><br><span class="line">while (right - left &gt; eps) &#123;</span><br><span class="line">mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">if (f(R, mid) &gt; r) &#123;</span><br><span class="line">right &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">left &#x3D; mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">double R, r;</span><br><span class="line">printf(&quot;请输入大圆半径R：&quot;);</span><br><span class="line">scanf_s(&quot;%lf&quot;, &amp;R);</span><br><span class="line">printf(&quot;请输入小圆半径r：&quot;);</span><br><span class="line">scanf_s(&quot;%lf&quot;, &amp;r);</span><br><span class="line">printf(&quot;水面高度为：%.4f\n&quot;, solve(R, r));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于VS2019无法使用scanf_s输如字符串问题的解决方法</title>
      <link href="/2020/01/11/%E5%85%B3%E4%BA%8EVS2019%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8scanf-s%E8%BE%93%E5%A6%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/11/%E5%85%B3%E4%BA%8EVS2019%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8scanf-s%E8%BE%93%E5%A6%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>至今没有弄好插图的问题，这篇文章算是挖的坑了吧，不知道什么时候能填上</p><a id="more"></a><p>这段时间来，我在VS2019开发环境下，发现了scanf_s(“%s”,&amp;d);这条语句无法像老版本那样正常执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char d[20];</span><br><span class="line">    scanf_s(&quot;%s&quot;, &amp;d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码输出若是mikegu的话，得到的结果则会是</p><p><img src="/.io//1.png" alt></p><p>不知道有没有人遇到和我一样的问题，查阅了网上的资料之后我发现解决方法其实非常简单，因为编译器会检测参数缺失，但无法确定缺少的参数是宽度或内容，所以它假定所提供的参数为第一个，而对于宽度，缺少参数为第二个类型转换说明符，必须检查格式字符串以确定实际缺少的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char d[20];</span><br><span class="line">    scanf_s(&quot;%s&quot;, &amp;d,sizeof(d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们人为的加上一个宽度，则算法可以正确执行了</p><p><img src="/.io//2.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法初尝试</title>
      <link href="/2020/01/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
      <url>/2020/01/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>贪心算法这个词我在去年备战考研初试的时候就已经接触过了，如今开始正式的对这种算法进行学习</p><a id="more"></a><p>所谓贪心算法，就是指再一定条件下争取最优解，谋求最大利益的一种算法，比如我今天学习时学到的月饼问题：厂家总共有n种月饼，市场总共有D千吨的需求量，每种月饼售价告诉你，让你求最大获利值</p><p>我们直接来看算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct mooncake &#123;</span><br><span class="line">double store;&#x2F;&#x2F;库存量</span><br><span class="line">double sell;&#x2F;&#x2F;总售价</span><br><span class="line">double price;&#x2F;&#x2F;单价</span><br><span class="line">&#125;cake[1010];</span><br><span class="line">bool cmp(mooncake a, mooncake b) &#123;</span><br><span class="line">return a.price &gt; b.price;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;上面都是声明</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;&#x2F;&#x2F;n是月饼种类</span><br><span class="line">double D;&#x2F;&#x2F;D是总需求量</span><br><span class="line">printf(&quot;输入月饼种类：&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;输入总需求量：&quot;);</span><br><span class="line">scanf_s(&quot;%lf&quot;, &amp;D);&#x2F;&#x2F;输入月饼种类和总需求量</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;输入第%d种月饼的库存：&quot;, i + 1);</span><br><span class="line">scanf_s(&quot;%lf&quot;, &amp;cake[i].store);</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;输入第%d种月饼的总售价：&quot;, i + 1);</span><br><span class="line">scanf_s(&quot;%lf&quot;, &amp;cake[i].sell);</span><br><span class="line">cake[i].price &#x3D; cake[i].sell &#x2F; cake[i].store;&#x2F;&#x2F;计算单价</span><br><span class="line">&#125;</span><br><span class="line">sort(cake, cake + n, cmp);&#x2F;&#x2F;按单价从高到底排序</span><br><span class="line">double ans &#x3D; 0;&#x2F;&#x2F;收益</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">if (cake[i].store &lt;&#x3D; D) &#123;&#x2F;&#x2F;如果需求量高于月饼库存量</span><br><span class="line">D -&#x3D; cake[i].store;&#x2F;&#x2F;第i种月饼全部卖出</span><br><span class="line">ans +&#x3D; cake[i].sell;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;&#x2F;&#x2F;如果月饼库存量高于需求量</span><br><span class="line">ans +&#x3D; cake[i].price * D;&#x2F;&#x2F;只卖出剩余需求量的月饼</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;最大可获利：%.2f\n&quot;, ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，在用sort按照price进行排序了之后，只要挑出price最高的月饼，如果该月饼的库存小于D，则全部卖出，弱不小于D，则卖出D千吨。是一种非常简单的算法，最主要的是对贪心算法进行一个大致的认识，以及练习了一下sort函数的应用。</p><p>我们来看第二个问题——最小数问题：给你0~9若干个数字，可以任意顺序地排列这些数字，0不可在第一个，使排列得到的数字尽可能的小，题目不是很难，我这里也直接给出算法吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">int count[10];&#x2F;&#x2F;记录数字0~9的个数</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;count[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i &lt; 10; i++) &#123;&#x2F;&#x2F;从1~9中选择最小的不为0的数字做首部</span><br><span class="line">if (count[i] &gt; 0) &#123;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">count[i]--;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;&#x2F;&#x2F;从小到大依次输出</span><br><span class="line">for (int j &#x3D; 0; j &lt; count[i]; j++) &#123;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果正在看本文的诸位也有像我一样的算法入门者对上面那个问题没什么思路的话，代码里的注释虽然不说很详细，但应该能有个大致的思路。</p><p>最后，我们来看今篇文章的小boss，区间贪心算法，给出N个开区间(x,y)，从中选择尽可能多的开区间，使得这些开区间两两没有交集。</p><p>1.首先先考虑一个区间I1被另一个区间I2包含的情况——自然选择其中较小的那一个</p><p>2.根据1.进行筛选后，按左端点x从小到大进行排序，一定会有右端点也从小到大进行排序（若不是这样，则会产生1.中情形），随后我们先选择左端点较大的即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 110;</span><br><span class="line">struct Inteval &#123;</span><br><span class="line">int x, y;&#x2F;&#x2F;开区间左右端点</span><br><span class="line">&#125;I[maxn];</span><br><span class="line">bool cmp(Inteval a, Inteval b) &#123;</span><br><span class="line">if (a.x !&#x3D; b.x)return a.x &gt; b.x;&#x2F;&#x2F;先按左端点从大到小排序</span><br><span class="line">else return a.y &lt; b.y;&#x2F;&#x2F;左端点相同的按右端点从小到大排序</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (printf(&quot;请输入区间个数：&quot;),scanf_s(&quot;%d&quot;, &amp;n), n !&#x3D; 0) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;请输入左端点：&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;I[i].x);</span><br><span class="line">printf(&quot;请输入右端点：&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;I[i].y);</span><br><span class="line">&#125;</span><br><span class="line">sort(I, I + n, cmp);&#x2F;&#x2F;把区间排序</span><br><span class="line">&#x2F;&#x2F;ans记录不相交区间个数，lastX记录上一个被选中区间的左端点</span><br><span class="line">int ans &#x3D; 1, lastX &#x3D; I[0].x;</span><br><span class="line">for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">if (I[i].y &lt;&#x3D; lastX) &#123;&#x2F;&#x2F;如果该区间右端点在lastX左边</span><br><span class="line">lastX &#x3D; I[i].x;&#x2F;&#x2F;以I[i]作为新选中的区间</span><br><span class="line">ans++;&#x2F;&#x2F;不相交区间个数加1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;最多有%d个不相交的区间\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若实在理解不了，可以像笔者一样，在草稿纸上画一堆区间，然后根据算法的步骤推进下去，由于笔者还暂时不会插入图片，图片解释这部分可能留到以后再进行修改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++编写的全排列递归算法</title>
      <link href="/2020/01/11/%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/11/%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天想分享的第一篇文章，是关于全排列递归的，昨天学习到的散列法可以牺牲空间来减少算法的时间开销，今天在学习全排列时，考虑到全排列本身的排列数就非常之多，那么利用散列法正好可以提高算法的执行效率，通过递归嵌套与循环结构的组合可以遍历所有的可能性，并在散列表中将已排数字标记，则可以极大地减少遍历次数</p><a id="more"></a><p>废话不多说，先上一组代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">const int maxn &#x3D; 11;</span><br><span class="line">&#x2F;&#x2F;P为当前排列，hashTable记录整数x是否已经在P中</span><br><span class="line">int n, P[maxn], hashTable[maxn] &#x3D; &#123; false &#125;;</span><br><span class="line">&#x2F;&#x2F;当前处理排列的第index号位</span><br><span class="line">void generateP(int index) &#123;</span><br><span class="line">if (index &#x3D;&#x3D; n + 1) &#123;&#x2F;&#x2F;递归边界，已经处理完排列1-n位</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">printf(&quot;%d&quot;, P[i]);&#x2F;&#x2F;输出当前排列</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;下面开始是核心递归式——循环里套递归，并用散列指明递归方向</span><br><span class="line">for (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;&#x2F;&#x2F;枚举1-n，试图将x填入P[index]</span><br><span class="line">if (hashTable[x] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;如果x不在P[0]~P[index]中</span><br><span class="line">P[index] &#x3D; x;&#x2F;&#x2F;令P的第index位为x，即把x加入当前排列</span><br><span class="line">hashTable[x] &#x3D; true;&#x2F;&#x2F;记x已在P中</span><br><span class="line">generateP(index + 1);&#x2F;&#x2F;处理排列的第index+1号位</span><br><span class="line">hashTable[x] &#x3D; false;&#x2F;&#x2F;已处理完P[index]为x的子问题，还原状态</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">n &#x3D; 3;&#x2F;&#x2F;1~3的全排列</span><br><span class="line">generateP(1);&#x2F;&#x2F;从P[1]开始填起</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的注释写的也很详细，但我在这还是想整理一下上面出现的一些小技巧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashTable[maxn]&#x3D;&#123;false&#125;</span><br></pre></td></tr></table></figure><p>这串代码就是昨天学习到的散列表法，长度为maxn的散列表，当元素n出现时，则将第n个元素的bool值变为true，查找时利用数组的随机访问特性，则可以非常迅速的找到相应的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void generateP(index)&#123;</span><br><span class="line">  if (index &#x3D;&#x3D; n + 1) &#123;...&#125;</span><br><span class="line">  for (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;</span><br><span class="line">    if (hashTable[x] &#x3D;&#x3D; false) </span><br><span class="line">    ..</span><br><span class="line">    generateP(index + 1);</span><br><span class="line">    ..</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码表示的就是递归，第一个if表示递归边界，也就是递归中止条件，紧随其后的佛如就是递归式，for里面的那个if则结合了散列表做标记，减少了遍历次数，指明了递归方向（即只往false的地方递归）generateP则是递归嵌套，每此嵌套都将关键值index加1</p><p>当然，上面那个算法只是一种思想，通常情况下我们也不会只是计算1~3的全排列，而且可能还有各种各样条件的限制，所以基于上面全排的思想，我想给出下面这个应用算法</p><p>n皇后问题</p><p>笔者是个国际象棋爱好者，皇后是国际象棋棋子中战略价值最高的一个棋子，可以直走可以横走可以斜着走，n皇后问题就是指：在一个n*n棋盘上，放置n个皇后，使这些皇不在不一行，不在同一列，不在同一条斜线上。</p><p>对于这个问题，枚举法显然计算量巨大，换个思路，我们看到每行每列都只能有一个皇后，是否能想到全排列，再加上一个额外的条件——不在同一条斜线上，那么将上面的全排列算法修改后我们可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">const int maxn &#x3D; 11;</span><br><span class="line">&#x2F;&#x2F;P为当前排列，hashTable记录整数x是否已经在P中</span><br><span class="line">int count &#x3D; 0, n, P[maxn], hashTable[maxn] &#x3D; &#123; false &#125;, i &#x3D; 1, j &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;当前处理排列的第index号位</span><br><span class="line">void generateP(int index) &#123;</span><br><span class="line">if (index &#x3D;&#x3D; n + 1) &#123;&#x2F;&#x2F;边界条件</span><br><span class="line">bool flag &#x3D; true;&#x2F;&#x2F;flag为true则表示当前方案为一个合法方案</span><br><span class="line">for (i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;&#x2F;&#x2F;遍历任意两个皇后，这里循环的是行号，每行一个皇后</span><br><span class="line">for (j &#x3D; i + 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">if (abs(i - j) &#x3D;&#x3D; abs(P[i] - P[j])) &#123;&#x2F;&#x2F;如果在同一条对角线上</span><br><span class="line">&#x2F;&#x2F;i-j表示前一个皇后的列数减去后一个皇后的列数</span><br><span class="line">&#x2F;&#x2F;P[i]-P[j]表示了两个意思，第一个是判断P[i]P[j]中有没有皇后，第二个是两个皇后的行数相减</span><br><span class="line">&#x2F;&#x2F;若两个皇后的列数相减等于行数相减，则就在同一斜线上</span><br><span class="line">flag &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag)</span><br><span class="line">count++;&#x2F;&#x2F;若当前方案合法，则计数count+1</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;</span><br><span class="line">if (hashTable[x] &#x3D;&#x3D; false) &#123;</span><br><span class="line">P[index] &#x3D; x;&#x2F;&#x2F;x表示列数，因为我们是一列列遍历过去的，用index表示列数，index依次递增，求得满足条件的行数，比如231就表示第一列第二行 第二列第三行 第三列第一行</span><br><span class="line">hashTable[x] &#x3D; true;</span><br><span class="line">generateP(index + 1);</span><br><span class="line">hashTable[x] &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">n &#x3D; 9;&#x2F;&#x2F;9*9的棋盘</span><br><span class="line">generateP(1);&#x2F;&#x2F;从P[1]开始填起</span><br><span class="line">printf(&quot;%d&quot;, count);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种n皇后算法枚举了所有可能性，但其实，有些可能性根本没必要举出，比如在2*2的棋盘中，随便第一列放置一个皇后，都不可能放得下第二个皇后，所以没必要枚举第二列的皇后</p><p>我们可以再得出优化之后的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 11;</span><br><span class="line">&#x2F;&#x2F;P为当前排列，hashTable记录整数x是否已经在P中</span><br><span class="line">int count &#x3D; 0, n, P[maxn], hashTable[maxn] &#x3D; &#123; false &#125;, i &#x3D; 1, j &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;当前处理排列的第index号位</span><br><span class="line">void generateP(int index) &#123;</span><br><span class="line">if (index &#x3D;&#x3D; n + 1) &#123;</span><br><span class="line">count++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;&#x2F;&#x2F;按行插入皇后</span><br><span class="line">if(hashTable[x]&#x3D;&#x3D;false)&#123;&#x2F;&#x2F;第x行还没有皇后</span><br><span class="line">bool flag &#x3D; true;&#x2F;&#x2F;true表示与之前的皇后没有冲突</span><br><span class="line">for (int pre &#x3D; 1; pre &lt; index; pre++) &#123;&#x2F;&#x2F;按列遍历之后的皇后</span><br><span class="line">&#x2F;&#x2F;index列皇后的行号为x，第pre列皇后的行号为P[pre]</span><br><span class="line">if (abs(index - pre) &#x3D;&#x3D; abs(x - P[pre])) &#123;</span><br><span class="line">&#x2F;&#x2F;index-pre 插入皇后的列号减去之前皇后的列号</span><br><span class="line">&#x2F;&#x2F;x-P[pre] 插入皇后的行号减去之前皇后的行号</span><br><span class="line">flag &#x3D; false;</span><br><span class="line">break;&#x2F;&#x2F;没必要继续进行下去</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (flag) &#123;&#x2F;&#x2F;如果可以把皇后放在第x行</span><br><span class="line">P[index] &#x3D; x;</span><br><span class="line">hashTable[x] &#x3D; true;</span><br><span class="line">generateP(index + 1);</span><br><span class="line">hashTable[x] &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">n &#x3D; 3;</span><br><span class="line">generateP(1);</span><br><span class="line">printf(&quot;%d&quot;, count);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++编写的两种有意思的空间换时间的算法</title>
      <link href="/2020/01/10/%E4%B8%A4%E7%A7%8D%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/10/%E4%B8%A4%E7%A7%8D%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今日在练习PAT时，看到两个简单的以空间换时间的查找法，感觉比较有意思，就整理了一下传了上来</p><a id="more"></a><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">bool hashTable[maxn] &#x3D; &#123; false &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, x;</span><br><span class="line">printf(&quot;请输入待查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;请输入查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;m);</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;请输入待查询数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;x);</span><br><span class="line">hashTable[x] &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">printf(&quot;请输入查询数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;x);</span><br><span class="line">if (hashTable[x] &#x3D;&#x3D; true) &#123;</span><br><span class="line">printf(&quot;有这个数\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;没有这个数\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法是在N个数中查找M个数，如果正常使用暴力破解法，则两层遍历需要的时间复杂度为O(MN)，当N和M都很大的时候这显然会导致巨大的开销，那么就牺牲空间来换取时间，利用bool hashTable[]数组来对输入的N进行预处理，当N中存在某个数时，hashTable[]中相应的就置为true，N中不存在则不做调整，那么当查询M的时候，利用静态数组的随机存取的特性，每一次查询一个数只需要O(1)的时间复杂度，查询M个数的时间复杂度为O(M)，整个算法的时间复杂度为O(M+N)，空间复杂度为O(N)</p><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">int hashTable[maxn] &#x3D; &#123; 0 &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m, x;</span><br><span class="line">printf(&quot;请输入待查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;请输入查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;m);</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;请输入待查询数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;x);</span><br><span class="line">hashTable[x]++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">printf(&quot;请输入查询数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;x);</span><br><span class="line">printf(&quot;有%d个\n&quot;, hashTable[x]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别急别急，这只是上面那个算法的变种，不是我说的第二种空间换时间的算法，这个算法的功能不仅在于输出有没有该数，更在于有几个所查询的数字</p><p>以上两个算法共有一个特性，就是将输入数直接作为数组下标，这个方法我觉得很实用，是一种比较常见的空间换时间的方法，但若查询数超过数组下标上限了呢？这就需要用到我今天学到的第二个精彩的方法——散列法，散列法的定义我就不做详述了，我觉得数据结构作为计算机的入门课程，大家肯定学的比我这个初学者要好的很多，这里散列法主要就是将那些非常大的数字通过一个函数转化为在规定范围内的整数</p><p>我们先来看看如何将字符串转化成一组数字</p><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int hashFunc(char S[], int len) &#123;</span><br><span class="line">int id &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">if (S[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; S[i] &lt;&#x3D; &#39;Z&#39;) &#123;&#x2F;&#x2F;0~25是大写字母</span><br><span class="line">id &#x3D; id * 62 + (S[i] - &#39;A&#39;);</span><br><span class="line">&#125;</span><br><span class="line">else if (S[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; S[i] &lt;&#x3D; &#39;z&#39;) &#123;</span><br><span class="line">id &#x3D; id * 62 + (S[i] - &#39;a&#39;) + 26;&#x2F;&#x2F;26~51是小写字母</span><br><span class="line">&#125;</span><br><span class="line">else if (S[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; S[i] &lt;&#x3D; &#39;9&#39;) &#123;</span><br><span class="line">id &#x3D; id * 62 + (S[i] - &#39;0&#39;) + 52;&#x2F;&#x2F;52~61是数字</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的算法我们可以看出，A<del>Z，a</del>z，0~9视为六十二进制数，将六十二进制数转化成十进制数，则就是该字符串所对应的数值，由此可知每一种字母排列组合所对应的数值是唯一的，那么当len不是很大时，我们就可以用散列法将字符串变成数字，以此来进行查找。</p><p>现在，我们结合空间换时间算法，散列法，来解决一个问题试试：给出N个字符串（由恰好三位大写字母组成），再给出M个查询字符串，问每个查询字符串在N个字符串中出现的次数</p><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int hashFuna(char S[], int len) &#123;&#x2F;&#x2F;只将大写字母进行转换</span><br><span class="line">int id &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">id &#x3D; id * 26 + (S[i] - &#39;A&#39;);&#x2F;&#x2F;字符串的字母按照二十六进制转化为十进制</span><br><span class="line">&#125;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">const int maxn &#x3D; 100;</span><br><span class="line">char S[maxn][5], temp[5];</span><br><span class="line">int hashTable[26 * 26 * 26 + 10];&#x2F;&#x2F;三个大写字母，每个字母为26进制，则需要263的空间大小</span><br><span class="line">int main() &#123;</span><br><span class="line">int n, m;</span><br><span class="line">printf(&quot;请输入待查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">printf(&quot;请输入查询数的个数：\n&quot;);</span><br><span class="line">scanf_s(&quot;%d&quot;, &amp;m);</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">printf(&quot;请输入待查询字符串（每个字符串由三个大写字母组成）：\n&quot;);</span><br><span class="line">scanf_s(&quot;%s&quot;, &amp;S[i], sizeof(S[i]));</span><br><span class="line">int id &#x3D; hashFuna(S[i], 3);</span><br><span class="line">hashTable[id]++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">printf(&quot;请输入查询字符串（每个字符串由三个大写字母组成）：\n&quot;);</span><br><span class="line">scanf_s(&quot;%s&quot;, &amp;temp, sizeof(temp));</span><br><span class="line">int id &#x3D; hashFuna(temp, 3);</span><br><span class="line">printf(&quot;有%d个该字符串\n&quot;, hashTable[id]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻求帮助，如何增添留言栏</title>
      <link href="/2020/01/10/%E5%AF%BB%E6%B1%82%E5%B8%AE%E5%8A%A9%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A2%9E%E6%B7%BB%E7%95%99%E8%A8%80%E6%A0%8F/"/>
      <url>/2020/01/10/%E5%AF%BB%E6%B1%82%E5%B8%AE%E5%8A%A9%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A2%9E%E6%B7%BB%E7%95%99%E8%A8%80%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<p>本人刚上手搭建hexo博客，很多功能还不是很熟悉<br>想搞一个评论的地方，但看国内许多提供评论的插件都已经停止服务<br>然后那个畅言好像还要写备案号<br>如果有谁有好用的评论插件，请联系QQ:437914030<br>或者没有也能加，期待与更多程序猿认识认识hhhhh</p>]]></content>
      
      
      
        <tags>
            
            <tag> 求助 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何C++中如何使用gets_s函数以及判断一个字符串是否为回文串</title>
      <link href="/2020/01/10/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95C-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gets-s%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2020/01/10/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95C-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gets-s%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>笔者今天正在准备考研复试机试，练到一道题，关于判断一个字符串是否是回文串——什么是回文串呢，就是指字符串是否关于中间对称，是的话该字符串就是回文串，然后笔者尝试在C++下用getchar()函数来完成这道题，但苦于getchar()是一个个输入，并且会录入回车，而判断回文串是直接判断一整个字符串。然后我就看到答案里是用gets来完成这道题的，在VS2019里，已经没有了gets，取而代之的是gets_s，不过这都无所谓，我觉得还蛮有趣的</p><a id="more"></a><p>所以大概整理了一下代码就传上来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#96;#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 256;</span><br><span class="line">bool judge(char str[]) &#123;</span><br><span class="line">int len &#x3D; strlen(str);</span><br><span class="line">for (int i &#x3D; 0; i &lt; len &#x2F; 2; i++) &#123;</span><br><span class="line">if (str[i] !&#x3D; str[len - 1 - i]) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;&lt;!--判断一个字符串中第i个字符和第len-1-i个字符是否一样----len为字符串长度--&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">char str[maxn];</span><br><span class="line">while (gets_s(str)) &#123;</span><br><span class="line">bool flag &#x3D; judge(str);</span><br><span class="line">if (flag &#x3D;&#x3D; true) &#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;&lt;!--这里是使用gets_s输入整个字符串到数组str[]中，回车键结束且不录入回车键--&gt;</span><br><span class="line"></span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于C++编写的进制转换</title>
      <link href="/2020/01/09/%E5%9F%BA%E4%BA%8EC-%E7%BC%96%E5%86%99%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/01/09/%E5%9F%BA%E4%BA%8EC-%E7%BC%96%E5%86%99%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>比较有意思的时，这里写的进制转换，不限与八进制十进制，十进制以下几进制转换都能进行</p><a id="more"></a><p>第一部分是最正常的进制转换</p><p>代码将分成两步：</p><p>1.将P进制数x转换为十进制y：</p><p>​    这步的思想是将x的第n位乘以P的n次方累加到y</p><p>2.将十进制数y转换为Q进制数z</p><p>​    这步的思想是将y除以Q，得到的余数存于低位，并将商继续重复前面的过程</p><p>第二部分是自己编写的一个输入两个十进制数输出这两个数在D进制下的和的函数</p><pre><code>#include &lt;iostream&gt;//将P进制的x转化为Q进制数输出int main(){    int x, P, product = 1, y = 0;//P是输入进制数，x是输入数，product用于计算P的n次方，y是十进制数    printf(&quot;请输入数字：&quot;);    scanf_s(&quot;%d&quot;, &amp;x);    printf(&quot;请输入进制数：&quot;);    scanf_s(&quot;%d&quot;, &amp;P);    while (x != 0) {        y = y + (x % 10) * product;        x = x / 10;        product = product * P;    }//将P进制数x转换为十进制yint z[40], num = 0, Q;//Q是输出进制数，z是输出数，num用来指示数组printf(&quot;请输入输出进制数：&quot;);scanf_s(&quot;%d&quot;, &amp;Q);do {    z[num++] = y % Q;    y = y / Q;} while (y != 0);//将十进制数y转换为Q进制数zprintf(&quot;输出的数字为：&quot;);for (int i = num - 1; i &gt;= 0; i--) {    printf(&quot;%d&quot;, z[i]);}//________________________________________________//下面的功能是输入十进制a和b，输出D进制的和int D, a, b;printf(&quot;\n下面进入add函数调试模块\n&quot;);printf(&quot;add函数功能是输入两个十进制数，输出他们的D进制数的和\n&quot;);printf(&quot;请输入进制数：&quot;);scanf_s(&quot;%d&quot;, &amp;D);printf(&quot;请输入两个十进制加数：&quot;);scanf_s(&quot;%d%d&quot;, &amp;a, &amp;b);printf(&quot;输出%d进制和为：&quot;, D);int all = a + b;int out[40], i;for (i = 0; all!=0; i++) {    out[i] = all % D;    all = all / D;}for (int p = i - 1; p &gt;= 0; p--) {    printf(&quot;%d&quot;, out[p]);}</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>讲讲如何在windows里配置git邮箱和密码吧</title>
      <link href="/2020/01/08/%E8%AE%B2%E8%AE%B2%E5%A6%82%E4%BD%95%E5%9C%A8windows%E9%87%8C%E9%85%8D%E7%BD%AEgit%E9%82%AE%E7%AE%B1%E5%92%8C%E5%AF%86%E7%A0%81%E5%90%A7/"/>
      <url>/2020/01/08/%E8%AE%B2%E8%AE%B2%E5%A6%82%E4%BD%95%E5%9C%A8windows%E9%87%8C%E9%85%8D%E7%BD%AEgit%E9%82%AE%E7%AE%B1%E5%92%8C%E5%AF%86%E7%A0%81%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>##写在最开头，本人刚转行计算机，啥都不是很会，但啥都想试试，所以搭建了这个博客，并打算先写一点简单的东西上传，如果能帮到大家就最好，帮不到大家就看个乐吧吧~~</p><a id="more"></a><p>首先在百度输入github进入官网</p><p>注册一个github账号，要填入邮箱、昵称、密码</p><p>注册完成并用邮箱验证完成后按照以下步骤进行</p><p>WIN+R 输入CMD调出控制台</p><p>输入</p><p>git config –global user.name “你刚刚注册填的昵称”</p><p>git config –global user.email “你刚刚注册填的邮箱”</p><p>这样就已经配置好了github全局昵称和邮箱</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/01/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/01/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>##写在代码生涯开始<br>搭建了两天的平台<br>终于弄好了我的个人博客<br>基于hexo框架<br>部署在github的ip上<br>由git bash、node.js、cnpm构成的环境<br>利用vim和typora进行文本编辑<br>本来以为一切顺利，昨天就能弄好<br>但中间出了不少错误<br>一次次搭建好了网站，却又一次次删除了镜像文件<br>一次次的乱码，上网搜攻略<br>不说完美无缺，但至少没什么大的毛病<br>我的个人博客终于搭建成功<br>希望能与大家有很多交流，程序员永远不孤军奋战！<br>写于2020年1月8号</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
